---  HackNet changelog
---  -----------------
---  
---  Daily entries, with more recent days on top.  Multiple checkins
---  on a single day are generally separated by blank lines, with the 
---  most recent checkins at the bottom.
---

April 30, 2001:
  Minor bugfixes to clean up some sloppy coding that was revealed when I
  finally remembered to build with -Wall.  Oops!

  Adjusted client to put text lines at topmost free line of buffer, instead
  of always writing to the bottom line and scrolling upwards.

  Added ENT_GridBug.cpp/.h class, to start implementing monsters and
  monster behaviour with.  (Well honestly, what else did you EXPECT to be 
  the first monster implemented?)  :)  TODO:  Implement a factory method
  to create monsters without the map having to create them explicitly.

April 29, 2001:
  Minor bugfix.  Sort of.  Was intentionally emulating what I believe is 
  a bug in the NetHack level generation code, involving the creation of
  corridors.  However, the results in HackNet were to cause many more
  corridors to be generated.  I've modified our intentionally emulated bug
  to perform the function that it looks like it _ought_ to be doing,
  and now the HackNet results more closely mirror NetHack's.  Perhaps
  NetHack was fixing the misbehaviour of the bug elsewhere in the code,
  or perhaps I was misunderstanding the purpose of the code in the first
  place (easy to do, with NetHack's codebase!)  Also, I've put in some
  early scaffolding for the near-future implementation of line-of-sight.

  Implemented rogue-style line-of-sight.  This is really a very poor
  implementation, and the rogue-style line-of-sight algorithm is poor,
  too, in this day and age.  Currently, you can see one square away
  in hallways, and the full room when standing inside a room.  Proper
  Line Of Sight code is a very, very big item on the TODO list, now.

  Added some checking into the line-of-sight stuff so that it only marks
  something as 'visible' for the purpose of sending to the client if
  that something has changed.. this means that what once was a 540 byte
  room being transferred every time you moved within the room is now a
  ~20 or ~30 byte packet each time you move, if nothing else within the
  room moves.  Much faster and easier on bad net connects!  Level changing
  still requires sending the whole level.  Expect to see this re-engineered
  before the release of version 0.0.3.

April 28, 2001:
  Client now sends name to server after connecting, and the server 
  displays the name in its packet trace messages (in addition to the 
  client ID number, as before).

  The netMetaPacket class hierarchy can now send 'String' types, in
  addition to 'Char', 'Short', and 'Long's.  Note that Char/Short/Long
  are explicitly coded to send 8, 16, and 32 bytes of data, respectively.
  For convenience, 'String' takes a char buffer, rather than an array of
  sint8s.  Also, String() takes a sint16 reference, stating the length
  of the array (This should really be a uint16, now that I stop and
  think about it), so that it doesn't read in/out too much data.

  The client code has been modified to redraw the full screen every
  frame (theoretically, curses should be taking care of not actually
  redrawing parts that haven't changed..  if this isn't the case, I'll
  need to make the code a little smarter).  This is to allow the printing
  of prompts over the map.  And speaking of prompts over the map...

  The client UI for talking has now been put into place.  Hit " to
  begin to speak, and hit enter to finish speaking.  Ain't it great?
  (Backspace isn't yet implemented, because I'm a lazy bastard).  :)

  Backspace now works in the client UI.  Client now sends the talk
  messages to the server, and the server displays them in its output.
  Next to be implemented:  Sending 'talk' strings to all clients.

  Speaking and shouting fully implemented.  To yell, put an exclamation
  point on the end of your 'talk' message.  Anyone within a seven square
  range of you will hear you speak, and everyone in the game will hear
  a shout.  Obviously, both ranges need tweaking, but this seems fair
  for a starting point.  Client currently shows the last three messages
  sent from the server.  (NetHack only shows two, but I expect that
  we'll be seeing somewhat more conversation than NetHack)  :)  Also
  moved the dungeon display down by four lines to make room for the
  messages and prompts to not overlap the dungeon.  Everything should
  still fit on a 24 line display (though only barely).  I'll probably
  have to lower the number of messages displayed and otherwise adjust
  to UI to be able to fit statistics at the bottom of the screen.

  I've been a busy little coder today, apparently!  Here's the next
  set of prezzies for you..  First, stairs are now generated, and you
  can now walk up and down them!  Second, the server now remembers
  the client's visual map of each level, and uses that for the data
  that's sent to each client (this means that we're much closer to
  being able to save/restore a client's state).  Third, the server
  now fully updates the client's vision every time they walk up or
  down a dungeon level -- this is done because the client only stores
  a single 'map' locally, and so when you go up or down a level, the
  contents of the new level are sent from the server to overwrite
  the old level..  the bad news is that on currently-sized levels,
  that amounts to more than 7k of data!  This is a lot more than
  I really want to be transferring for a single move, so I suspect I'll
  need to rewrite this system to make the clients a bit smarter..
  perhaps make the clients remember all maps they see within each
  play session, and just have the server send all vision data to the
  clients whenever resuming a saved play session.. that way, we
  don't have to transfer 7k each time you change levels, just transfer
  up to 50 dungeon levels times 7k each during the initial connection
  process..  (But that's 350k, which can take a lot of time to
  transfer on slow modem connections, even if it's only done once!)

  Moved Visibility code into the mapBase class..  currently you call
  UpdateVisibility for a map to update its own visibility information
  based upon the map you pass in as a parameter, but I might reverse
  that so that particular classes of maps can override visibility
  calculating functions..  (This would be useful for the different
  visibility algorithm that will need to be used in the Rogue level,
  for example!)  This also means that the entPlayer won't need to
  change when correct visibility is moved into the code -- it'll
  automatically send the right visibility update data to the client.

---
April 27, 2001:
  Adjusted client argument parsing.  Client still defaults to 'localhost'
  if no other host is provided.  Added player 'name' argument reading,
  using identical '-u Name' syntax to that used by NetHack (so either
  '-u Name' or '-uName' will work)..  if no name is specified on the
  command line, then HackNet will fill in the name from the USER
  environment variable.  If there's no USER environment variable, then
  the LOGNAME variable is used.  If that doesn't exist either, then
  the name 'Unknown' is used.  (NetHack asks explicitly for a name
  in this case -- implementing that is a 'TODO' for HackNet).  The
  name isn't yet transferred to the server, but expect to see that
  tomorrow.

---
April 26, 2001:
  Adjusted client to use the (relatively) new netMetaPacket code that
  was originally written for the server.  Better code reusability, and
  easier to add new packet types.  (Particularly when sending strings
  over the net!)  WARNING:  The switch to the MetaPacket results in the
  requirement of accepting 16 bits worth of packet 'size' data, which
  means that in the current implementation, a malicious client could
  freeze up the server by connecting and sending a single byte of data --
  the server will block until it receives a second byte of data!  This
  is a high-priority fix for me.  I deserve to be slapped around for
  even thinking about knowingly checking the code with this sort of
  security flaw present..  but I'm doing it anyway.  Expect a fix for
  this issue within the next day or two.  :)

---
April 25, 2001:
  How sad is this -- I even put in a change on ANZAC day.  I ought to get
  my priorities straight!  ;)

  I actually did a major restruturing of the code to properly generate
  NetHack-style levels through identical code to that used in NetHack...
  and then realised that the NetHack code is functionally equivalent to
  what I already had (with one or two minor factors that I'd missed
  before)..  the NetHack version of the code is more efficient in CPU
  time and memory, but my version is more intuitive to the casual
  examiner (or so I like to believe), so I threw out all those changes
  and went back to the original code.  I've added in one or two factors
  that I'd missed before, though, such as limits on the maximum area of
  rooms.  (Currently hardcoded to 50 -- the same as in NetHack)

---
April 24, 2001:
  Long day at work -- not much time to work on HackNet.  Added ability
  for the client to connect to an internet server, and tested it on my
  local LAN.  No tests yet over the real Internet.  Note that we're using
  TCP, and so delivery is guaranteed.. but this also means that we have
  extra header data added to each packet.  Since most of our packets are
  quite small, it might be silly to use TCP -- we've almost always got
  larger packet headers than information in the packet!  Perhaps a switch
  to UDP is in the cards...  On the other hand, automatic guaranteed 
  delivery is a luxury I'm not eager to throw out.

  Oops.  My mistake -- another checkin so that the client still connects
  to localhost if called without parameters, instead of trying to
  connect to ./hacknet (or however you invoke the client).  Until the
  game is more playable, 99% of the time, connecting to localhost is
  going to be what you actually want to do, for testing purposes.  Once
  the game is more playable, I'll remove this default behaviour, and
  force an explicit hostname.  (Perhaps a ~/.hacknetrc file which lists,
  among other options, a default server?)

---
April 23, 2001:
  Minor adjustment to temporary movement code still in HN_Game.cpp to fix
  a potential bug.  Before, if a non-moving player saw a monster move 
  (currently unimplemented -- hence, potential bug), that monster would
  have shown up as a human player.  Fixed now.  Not that anybody will
  notice the change until monster movement is added.  And that won't
  happen until monsters are added.  So much to do!

  Removed HN_Consts.h, which was storing a level width/height.  This was
  just an ugly hack, to synchronise the size of the client's map with
  the server's map.  Now the server sends the client a 'map reset' packet
  when the client joins, which tells the client what size map it's going
  to use.  The server should also send this packet to the client every time
  the client moves to a new level (even if that level had been seen before).
  This tells the client to purge its memory of what level it's currently on.
  The server should ALWAYS follow the mapReset information with a full map
  refresh if the client has moved to a level he's visited before, and then
  with a set of visibility information, regardless of whether the player
  has visited that map before.

  Fixed minor bugs in MAP_Hack.cpp.  Rooms are no longer generated touching
  bottom border of the screen so frequently (silly case of using width when
  I ought to have been using height).  Other minor issues fixed, too.

---
April 22, 2001:
  Big changes today.  Here's the scoop:
  
  Added MAP_Client.cpp/.h.  This is a minimalist-implementation of mapBase
  functionality, without dependencies on the entBase and objBase classes
  (which the client isn't going to need).  Instead, it stores known map data
  and an entity type and an object type for each square.  (It needs to be able
  to store an object array for each square.. but we'll work on that later)

  Here's the biggie, though..  I've moved about half of the movement code
  into the entBase and entPlayer classes.  Once turns are properly synched
  between nearby players, I'll be able to remove the rest of the movement
  code, because it'll no longer be required.  (The movement code still in
  hnGame is there to synchronise the movements of moving players with the
  vision of non-moving players, if that makes any sense).

  Moved enumerations from OBJ/ENT_Base.h into OBJ/ENT_Types.h  This is so
  that the client code can get the types without including the object and
  entity class declarations (which it doesn't need).

  Fixed Makefile.am to remove some unneeded source files from the client.  My
  mistake.  :)   (They'd just be removed in the linking process, but now
  'make hacknet' doesn't have to compile quite so many source files)

  Removed 'playerData' structure from hnGame class.  It just stores pointers
  to entPlayer classes now -- the entPlayers keep track of their own extra
  data.  Hooray for object-oriented code!

---
April 21, 2001:
  Lots of renamed files, to make a more consistant file naming scheme.  Objects now
  have an OBJ prefix, Entities (players, monsters, etc) now have an ENT prefix, and
  Maps now have a MAP prefix.  Core classes still use HN, and network classes still
  use NET.

  Adjusted the hnGame and netServer classes.  The netServer has a pointer to the
  hnGame, which has a pointer to the lower-level guts of the simulation.  Both
  the netServer and the hnGame are singletons (possibly the hnGame shouldn't be
  a singleton -- to be considered for future updates).  This is in preparation
  for migrating the player update logic from the hnGame object into the entPlayer
  object.

  Added hnDungeon class (singleton) to own all the levels in the dungeon.  Again,
  trying to move as much out of the hnGame as possible, in preparation for moving
  the movement code into the entPlayer.
---
April 1, 2001:
  Continued discussions about timing issues.
  Adjusted object class hierarchy -- 'hnEntity' is now at the top of the hierarchy,
  with 'hnObject' and 'hnCreature' derived from it.  Players and monsters will be
  derived from hnCreature, while inanimate objects will be derived from hnObject.
---
March 11, 2001:
  Development kicks into gear and first code entered into SourceForge CVS repository
---
Dec 8, 2000:
  First code entered into CVS repository
---
